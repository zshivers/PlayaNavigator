#include <gtest/gtest.h>

#include "coordinates.h"

void PrintTo(const PlayaAddress& address, std::ostream* os) {
  *os << "(" << int(address.hour) << ":" << int(address.minute) << " & "
      << address.road << ")";
}

namespace {
constexpr double feetToMeters(const double feet) { return feet / 3.281; }

TEST(LatLonToPlayaCoords, Translation) {
  constexpr PlayaMapConfig kPlayaMapConfig = {
      .center = {.lat = 0.0, .lon = 0.0},
      .rotation_deg = 0.0,
  };
  // Using coordinates generated by https://www.gpsvisualizer.com/calculators
  PlayaCoords pc = LatLonToPlayaCoords(
      kPlayaMapConfig, {.lat = 0.00637334527, .lon = 0.00637334527});
  std::cout << pc.angle_deg << "deg,  " << pc.radius_m << "m \n";
  EXPECT_NEAR(pc.radius_m, 1000, 10);
  EXPECT_NEAR(pc.angle_deg, 45, 0.1);
  // -134.8
}

TEST(LatLonToPlayaCoords, TranslationAndRotation) {
  constexpr PlayaMapConfig kPlayaMapConfig = {
      .center = {.lat = 0.0, .lon = 0.0},
      .rotation_deg = -45.0,
  };
  PlayaCoords pc = LatLonToPlayaCoords(
      kPlayaMapConfig, {.lat = 0.00637334527, .lon = 0.00637334527});
  EXPECT_NEAR(pc.radius_m, 1000, 10);
  EXPECT_NEAR(pc.angle_deg, 0, 0.1);
}

// Test using points derived from BM's published map info for 2022, found here:
// https://bm-innovate.s3.amazonaws.com/2022/2022_BRC_Measurements.pdf
constexpr PlayaMapConfig kPlayaMapConfig = {
    .center = {.lat = 40.787030, .lon = -119.202740},
    // True north/south line is along 4:30 = (360 deg / 12 h) * (6 - 4.5) = 45
    // deg
    .rotation_deg = -45.0,
    .esplanade_radius_m = feetToMeters(2500.0),
    .last_road_radius_m = feetToMeters(11690.0 / 2.0),  // 5845
    .trash_fence_radius_m = feetToMeters(8491.0),
    .roads = {{
        {'S', feetToMeters(2500)},
        {'A', feetToMeters(2940)},
        {'B', feetToMeters(3230)},
        {'C', feetToMeters(3520)},
        {'D', feetToMeters(3810)},
        {'E', feetToMeters(4100)},
        {'F', feetToMeters(4590)},
        {'G', feetToMeters(4880)},
        {'H', feetToMeters(5170)},
        {'I', feetToMeters(5460)},
        {'J', feetToMeters(5650)},
        {'K', feetToMeters(5840)},
    }},
};

//
//
TEST(LatLonToPlayaCoords, BurningMan2022Map) {
  PlayaCoords pc = LatLonToPlayaCoords(kPlayaMapConfig,
                                       {.lat = 40.803538, .lon = -119.181098});
  // P3 point is at 12:00.
  // Man to outer fence pentagon points: 8491â€™ = 2588.057 meters
  EXPECT_NEAR(pc.radius_m, feetToMeters(8491), 10);
  EXPECT_NEAR(pc.angle_deg, 0, 0.5);
}

TEST(LatLonToPlayaCoords, BurningMan2022Map_9andEsplanade) {
  // 9:00 & Espalande
  PlayaCoords pc = LatLonToPlayaCoords(
      kPlayaMapConfig, {.lat = 40.791875, .lon = -119.209115});
  EXPECT_NEAR(pc.radius_m, feetToMeters(2500), 10);
  EXPECT_NEAR(pc.angle_deg, -90, 2);
}

TEST(LatLonToPlayaCoords, BurningMan2022Map_3andEsplanade) {
  // 3:00 & Espalande
  PlayaCoords pc = LatLonToPlayaCoords(
      kPlayaMapConfig, {.lat = 40.782185, .lon = -119.196366});
  EXPECT_NEAR(pc.radius_m, feetToMeters(2500), 10);
  EXPECT_NEAR(pc.angle_deg, 90, 2);
}

TEST(IsAddressable, CloseToTheMan) {
  EXPECT_FALSE(
      IsAddressable(kPlayaMapConfig, {.radius_m = 80.0, .angle_deg = 5.0}));
}

TEST(IsAddressable, InnerPlaya) {
  EXPECT_FALSE(IsAddressable(
      kPlayaMapConfig, {.radius_m = feetToMeters(2499.0), .angle_deg = -90.0}));
}

TEST(IsAddressable, Between10and2) {
  EXPECT_FALSE(IsAddressable(
      kPlayaMapConfig, {.radius_m = feetToMeters(4000.0), .angle_deg = 0.0}));
}

TEST(IsAddressable, InCity) {
  EXPECT_TRUE(IsAddressable(
      kPlayaMapConfig, {.radius_m = feetToMeters(4000.0), .angle_deg = 90.0}));
  EXPECT_TRUE(IsAddressable(
      kPlayaMapConfig, {.radius_m = feetToMeters(4000.0), .angle_deg = -90.0}));
  EXPECT_TRUE(IsAddressable(
      kPlayaMapConfig, {.radius_m = feetToMeters(4000.0), .angle_deg = 180.0}));
}

TEST(IsAddressable, PastLastRoad) {
  EXPECT_FALSE(IsAddressable(
      kPlayaMapConfig, {.radius_m = feetToMeters(5900.0), .angle_deg = 45.0}));
}

TEST(IsAddressable, DeepPlaya) {
  EXPECT_FALSE(IsAddressable(
      kPlayaMapConfig, {.radius_m = feetToMeters(6000.0), .angle_deg = 15.0}));
}

TEST(PlayaCoordsToAddress, DeepPlayaHasNoAddress) {
  std::optional<PlayaAddress> address = PlayaCoordsToAddress(
      kPlayaMapConfig, {.radius_m = feetToMeters(6000.0), .angle_deg = 15.0});
  EXPECT_FALSE(address.has_value());
}

TEST(PlayaCoordsToAddress, EsplanadeAnd9) {
  std::optional<PlayaAddress> address = PlayaCoordsToAddress(
      kPlayaMapConfig, {.radius_m = feetToMeters(2600.0), .angle_deg = -90.0});
  ASSERT_TRUE(address.has_value());
  PlayaAddress expected = {.hour = 9, .minute = 0, .road = 'S'};
  EXPECT_EQ(*address, expected);
}

TEST(PlayaCoordsToAddress, Cand3) {
  std::optional<PlayaAddress> address = PlayaCoordsToAddress(
      kPlayaMapConfig, {.radius_m = feetToMeters(3520.0), .angle_deg = 90.0});
  ASSERT_TRUE(address.has_value());
  PlayaAddress expected = {.hour = 3, .minute = 0, .road = 'C'};
  EXPECT_EQ(*address, expected);
}

TEST(PlayaCoordsToAddress, Jand6) {
  std::optional<PlayaAddress> address = PlayaCoordsToAddress(
      kPlayaMapConfig, {.radius_m = feetToMeters(5650.0), .angle_deg = 180.0});
  ASSERT_TRUE(address.has_value());
  PlayaAddress expected = {.hour = 6, .minute = 0, .road = 'J'};
  EXPECT_EQ(*address, expected);
}

TEST(PlayaCoordsToAddress, Fand815) {
  std::optional<PlayaAddress> address = PlayaCoordsToAddress(
      kPlayaMapConfig, {.radius_m = feetToMeters(4590.0), .angle_deg = -112.5});
  ASSERT_TRUE(address.has_value());
  PlayaAddress expected = {.hour = 8, .minute = 15, .road = 'F'};
  EXPECT_EQ(*address, expected);
}

TEST(PlayaCoordsToAddress, ClockAddressIsRounded) {
  // 6:03 should be rounded up to 6:05.
  std::optional<PlayaAddress> address = PlayaCoordsToAddress(
      kPlayaMapConfig, {.radius_m = feetToMeters(2600.0), .angle_deg = -178.5});
  ASSERT_TRUE(address.has_value());
  PlayaAddress expected = {.hour = 6, .minute = 5, .road = 'S'};
  EXPECT_EQ(*address, expected);
}

}  // namespace

int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&argc, argv);
  // if you plan to use GMock, replace the line above with
  // ::testing::InitGoogleMock(&argc, argv);

  if (RUN_ALL_TESTS())
    ;

  // Always return zero-code and allow PlatformIO to parse results
  return 0;
}